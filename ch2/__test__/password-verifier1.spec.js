const { PasswordVerifier1 } = require("../verifyPassword1");

// Listing 2.11 Testing the stateful unit of work
describe("PasswordVerifier", () => {
  describe("with a failing rule", () => {
    it("has an error message based on the rule.reason", () => {
      const verifier = new PasswordVerifier1();
      const fakeRule = (input) => ({ passed: false, reason: "fake reason" });
      verifier.addRule(fakeRule);

      const errors = verifier.verify("any value");

      expect(errors[0]).toContain("fake reason");
    });
  });
});

// Listing 2.12 Checking an extra end result from the same exit point
describe("PasswordVerifier", () => {
  describe("with a failing rule", () => {
    it("has an error message based on the rule.reason", () => {
      const verifier = new PasswordVerifier1();
      const fakeRule = (input) => ({ passed: false, reason: "fake reason" });
      verifier.addRule(fakeRule);

      const errors = verifier.verify("any value");

      expect(errors[0]).toContain("fake reason");
    });
    it("has exactly one error", () => {
      const verifier = new PasswordVerifier1();
      const fakeRule = (input) => ({ passed: false, reason: "fake reason" });
      verifier.addRule(fakeRule);

      const errors = verifier.verify("any value");

      expect(errors.length).toBe(1);
    });
  });
});

// Listing 2.13 Using beforeEach() on two levels
describe("PasswordVerifier", () => {
  let verifier;

  beforeEach(() => {
    verifier = new PasswordVerifier1();
  });

  describe("with a failing rule", () => {
    let fakeRule, errors;

    beforeEach(() => {
      // Only Arrange
      fakeRule = (input) => {
        return {
          passed: false,
          reason: "fake reason",
        };
      };
      verifier.addRule(fakeRule);
    });

    it("has an error message based on the rule.reason", () => {
      const errors = verifier.verify("any value");

      expect(errors[0]).toContain("fake reason");
    });

    it("has exactly one error", () => {
      const errors = verifier.verify("any value");

      expect(errors.length).toBe(1);
    });
  });
});

// Listing 2.14 Pushing the arrange and act parts into beforeEach()
describe("PasswordVerifier", () => {
  let verifier;

  beforeEach(() => (verifier = new PasswordVerifier1()));

  describe("with a failing rule", () => {
    let fakeRule, errors;

    beforeEach(() => {
      // Arrange
      fakeRule = (input) => ({ passed: false, reason: "fake reason" });
      verifier.addRule(fakeRule);
      // Act
      errors = verifier.verify("any value");
    });

    it("has an error message based on the rule.reason", () => {
      expect(errors[0]).toContain("fake reason");
    });

    it("has exactly one error", () => {
      expect(errors.length).toBe(1);
    });
  });
});

// Listing 2.15 Adding extra scenarios
describe("v6 PasswordVerifier", () => {
  let verifier;

  beforeEach(() => (verifier = new PasswordVerifier1()));

  describe("with a failing rule", () => {
    let fakeRule, errors;

    beforeEach(() => {
      fakeRule = (input) => ({ passed: false, reason: "fake reason" });
      verifier.addRule(fakeRule);

      errors = verifier.verify("any value");
    });

    it("has an error message based on the rule.reason", () => {
      expect(errors[0]).toContain("fake reason");
    });

    it("has exactly one error", () => {
      expect(errors.length).toBe(1);
    });
  });

  describe("with a passing rule", () => {
    let fakeRule, errors;

    beforeEach(() => {
      fakeRule = (input) => ({ passed: true, reason: "" });
      verifier.addRule(fakeRule);

      errors = verifier.verify("any value");
    });

    it("has no errors", () => {
      expect(errors.length).toBe(0);
    });
  });

  describe("with a failing and a passing rule", () => {
    let fakeRulePass, fakeRuleFail, errors;

    beforeEach(() => {
      fakeRulePass = (input) => ({ passed: true, reason: "fake success" });
      fakeRuleFail = (input) => ({ passed: false, reason: "fake reason" });
      verifier.addRule(fakeRulePass);
      verifier.addRule(fakeRuleFail);

      errors = verifier.verify("any value");
    });

    it("has one error", () => {
      expect(errors.length).toBe(1);
    });

    it("error text belongs to failed rule", () => {
      expect(errors[0]).toContain("fake reason");
    });
  });
});

// Listing 2.16 Adding a couple of factory methods to the mix
describe("PasswordVerifier", () => {
  let verifier;
  beforeEach(() => (verifier = new PasswordVerifier1()));

  describe("with a failing rule", () => {
    let errors;

    beforeEach(() => {
      verifier.addRule(makeFailingRule("fake reason"));

      errors = verifier.verify("any value");
    });

    it("has an error message based on the rule.reason", () => {
      expect(errors[0]).toContain("fake reason");
    });

    it("has exactly one error", () => {
      expect(errors.length).toBe(1);
    });
  });

  describe("with a passing rule", () => {
    let errors;

    beforeEach(() => {
      verifier.addRule(makePassingRule());

      errors = verifier.verify("any value");
    });

    it("has no errors", () => {
      expect(errors.length).toBe(0);
    });
  });

  describe("with a failing and a passing rule", () => {
    let errors;

    beforeEach(() => {
      verifier.addRule(makePassingRule());
      verifier.addRule(makeFailingRule("fake reason"));

      errors = verifier.verify("any value");
    });

    it("has one error", () => {
      expect(errors.length).toBe(1);
    });

    it("error text belongs to failed rule", () => {
      expect(errors[0]).toContain("fake reason");
    });
  });

  // factory methods
  const makeFailingRule = (reason) => {
    return (input) => {
      return { passed: false, reason: reason };
    };
  };

  const makePassingRule = () => (input) => {
    return { passed: true, reason: "" };
  };
});

// Listing 2.17 Replacing beforeEach() with factory methods
const makeVerifier = () => new PasswordVerifier1();
const passingRule = (input) => ({ passed: true, reason: "" });
const makeVerifierWithPassingRule = () => {
  const verifier = makeVerifier();
  verifier.addRule(passingRule);
  return verifier;
};

const makeVerifierWithFailedRule = (reason) => {
  const verifier = makeVerifier();
  const fakeRule = (input) => ({ passed: false, reason: reason });
  verifier.addRule(fakeRule);
  return verifier;
};

describe("PasswordVerifier", () => {
  describe("with a failing rule", () => {
    it("has an error message based on the rule.reason", () => {
      const verifier = makeVerifierWithFailedRule("fake reason");
      const errors = verifier.verify("any input");
      expect(errors[0]).toContain("fake reason");
    });

    it("has exactly one error", () => {
      const verifier = makeVerifierWithFailedRule("fake reason");
      const errors = verifier.verify("any input");
      expect(errors.length).toBe(1);
    });
  });

  describe("with a passing rule", () => {
    it("has no errors", () => {
      const verifier = makeVerifierWithPassingRule();
      const errors = verifier.verify("any input");
      expect(errors.length).toBe(0);
    });
  });

  describe("with a failing and a passing rule", () => {
    it("has one error", () => {
      const verifier = makeVerifierWithFailedRule("fake reason");
      verifier.addRule(passingRule);

      const errors = verifier.verify("any input");

      expect(errors.length).toBe(1);
    });

    it("error text belongs to failed rule", () => {
      const verifier = makeVerifierWithFailedRule("fake reason");
      verifier.addRule(passingRule);

      const errors = verifier.verify("any input");

      expect(errors[0]).toContain("fake reason");
    });
  });
});

// Listing 2.18 Removing nested describes
test(
  "pass verifier, with failed rule, " +
    "has an error message based on the rule.reason",
  () => {
    const verifier = makeVerifierWithFailedRule("fake reason");
    const errors = verifier.verify("any input");
    expect(errors[0]).toContain("fake reason");
  }
);

test("pass verifier, with failed rule, has exactly one error", () => {
  const verifier = makeVerifierWithFailedRule("fake reason");
  const errors = verifier.verify("any input");
  expect(errors.length).toBe(1);
});

test("pass verifier, with passing rule, has no errors", () => {
  const verifier = makeVerifierWithPassingRule();
  const errors = verifier.verify("any input");
  expect(errors.length).toBe(0);
});

test("pass verifier, with passing and failing rule," + " has one error", () => {
  const verifier = makeVerifierWithFailedRule("fake reason");
  verifier.addRule(passingRule);

  const errors = verifier.verify("any input");

  expect(errors.length).toBe(1);
});

test(
  "pass verifier, with passing and failing rule," +
    " error text belongs to failed rule",
  () => {
    const verifier = makeVerifierWithFailedRule("fake reason");
    verifier.addRule(passingRule);

    const errors = verifier.verify("any input");

    expect(errors[0]).toContain("fake reason");
  }
);

// Listing 2.25 Testing exceptions with try/catch
test("verify, with no rules, throws exception", () => {
  const verifier = makeVerifier();
  try {
    verifier.verify("any input");
    fail("error was expected but not thrown");
  } catch (e) {
    expect(e.message).toContain("no rules configured");
  }
});

// Listing 2.26 Using expect().toThrow()
test("verify, with no rules, throws exception", () => {
  const verifier = makeVerifier();
  expect(() => verifier.verify("any input")).toThrow(/no rules configured/);
});
